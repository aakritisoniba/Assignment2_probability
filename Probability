import random

def simulate_coin_tosses(n=10000):
    heads = 0
    for _ in range(n):
        if random.choice(['H', 'T']) == 'H':
            heads += 1
    tails = n - heads
    print(f"Probability of Heads: {heads/n}")
    print(f"Probability of Tails: {tails/n}")

simulate_coin_tosses()

#This will simulate tossing a coin 10,000 times using random choices, and counts how often heads or tails will appear to finally calculate the experimental probability.


def simulate_dice_rolls(trials=10000):
    count_sum_7 = 0
    for _ in range(trials):
        die1 = random.randint(1, 6)
        die2 = random.randint(1, 6)
        if die1 + die2 == 7:
            count_sum_7 += 1
    print(f"Probability of sum = 7: {count_sum_7/trials}")

simulate_dice_rolls()

#Rolls two dice repeatedly and counts how many times the sum is 7.


def estimate_at_least_one_six(trials=10000):
    success = 0
    for _ in range(trials):
        if 6 in [random.randint(1, 6) for _ in range(10)]:
            success += 1
    print(f"Probability of at least one 6 in 10 rolls: {success/trials}")

estimate_at_least_one_six()

#Rolls the dice 10 times for each trial and checks if at least one out of all roll is 6.


def simulate_ball_draws(trials=1000):
    colors = ['red']*5 + ['green']*7 + ['blue']*8
    previous_color = None
    blue_then_red = 0
    total_after_blue = 0

    for _ in range(trials):
        current = random.choice(colors)
        if previous_color == 'blue':
            total_after_blue += 1
            if current == 'red':
                blue_then_red += 1
        previous_color = current

    if total_after_blue > 0:
        conditional_prob = blue_then_red / total_after_blue
        print(f"P(Red | Previous was Blue): {conditional_prob}")
    else:
        print("Not enough data for conditional probability")

simulate_ball_draws()

#This will simulate drawing a ball and putting it back 1000 times, tracking when a red ball follows a blue one.


import numpy as np

def discrete_rv_stats():
    sample = np.random.choice([1, 2, 3], size=1000, p=[0.25, 0.35, 0.4])
    mean = np.mean(sample)
    variance = np.var(sample)
    std_dev = np.std(sample)
    print(f"Mean: {mean}, Variance: {variance}, Standard Deviation: {std_dev}")

discrete_rv_stats()

# We will generate 1000 random values from a custom discrete distribution and calculate statistical properties.



import matplotlib.pyplot as plt
import seaborn as sns

def exponential_distribution_sim():
    data = np.random.exponential(scale=5, size=2000)
    sns.histplot(data, kde=True, stat='density', bins=30, color='skyblue')
    plt.title('Exponential Distribution with PDF Overlay')
    plt.xlabel('Value')
    plt.ylabel('Density')
    plt.show()

exponential_distribution_sim()

#Simulates 2000 samples from an exponential distribution and overlays a probability density function on the histogram.



def simulate_clt():
    uniform_data = np.random.uniform(0, 1, 10000)
    sample_means = [np.mean(np.random.choice(uniform_data, size=30)) for _ in range(1000)]

    # plot original uniform distribution
    plt.subplot(1, 2, 1)
    sns.histplot(uniform_data, bins=30, color='lightgreen')
    plt.title('Uniform Distribution')

    # plot distribution of sample means
    plt.subplot(1, 2, 2)
    sns.histplot(sample_means, bins=30, color='orange', kde=True)
    plt.title('Distribution of Sample Means (CLT)')

    plt.tight_layout()
    plt.show()

simulate_clt()

#this will show how the distribution of sample means approaches normal distribution (i.e. bell curve), even when the original data is uniform.

